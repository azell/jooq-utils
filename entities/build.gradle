plugins {
  id("java-library")
}

configurations {
  openjpa
}

dependencies {
  openjpa(Libs.openjpaAll)
  openjpa(Libs.postgresql)

  annotationProcessor(Libs.jpaModelGen)

  api(Libs.hibernateCore, Libs.hibernateTypes)
  api(Libs.javaxPersistenceApi)
}

def src = "${buildDir}/generated-src/openjpa"
def dst = "${buildDir}/generated-src/raw"

sourceSets {
  main {
    java {
      srcDirs(src)
    }
  }
}

tasks {
  compileJava {
    dependsOn("filterEntities")

    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
  }
}

def columnDefinition(line, types, state) {
  def matcher = line =~ /(.*@Column\b.*\bcolumnDefinition\b[^"]*")([^"]*)(.*)/

  if (matcher) {
    def e = types.find { it.key == matcher.group(2) }

    if (e) {
      // placeholder for field definition
      state._ = e

      def type = e.value.name

      return [
        "${matcher.group(1)}$e.value.columnDefinition${matcher.group(3)}",
        type ? "@org.hibernate.annotations.Type(type=$type)" : null,
      ].findResults { it }.join(" ")
    }
  }

  line
}

def fieldDefinition(line, types, state) {
  def matcher = line =~ /(.*\bprivate\b\s*)(\S*)(.*)/

  if (matcher) {
    def e = state._
    state._ = null

    if (e) {
      def field = matcher.group(3).replaceAll("[^\$\\w]", "")
      state[field] = e

      return "${matcher.group(1)}$e.value.fieldDefinition${matcher.group(3)}"
    }
  }

  line
}

def generatedValue(line, types, state) {
  if (line =~ /@Id\b/) {
    return "$line @GeneratedValue(strategy=GenerationType.IDENTITY)"
  }

  line
}

def getterOrSetter(line, types, state) {
  def matcher = line =~ /(.*\bpublic\b.*\b[gs]et)([$\w]*)(.*)/

  if (matcher) {
    def e = state[matcher.group(2).uncapitalize()]

    if (e) {
      return line.replace("byte[]", e.value.fieldDefinition)
    }
  }

  line
}

def typeDefs(line, types, state) {
  if (line =~ /@Table\b/) {
    def str = types.collect { k, v ->
      def attrs = ["defaultForType", "name", "typeClass"].findResults {
        v.containsKey(it) ? "$it=${v[it]}" : null
      }.join(", ")

      "@org.hibernate.annotations.TypeDef($attrs)"
    }.join(", ")

    return "$line @org.hibernate.annotations.TypeDefs({ $str })"
  }

  line
}


task filterEntities(type: Copy) {
  dependsOn("openjpa")

  def state = [:]
  def types = [
    _text: [
      columnDefinition: "text[]",
      fieldDefinition: "java.util.List<String>",
      name: "\"list-array\"",
      typeClass: "com.vladmihalcea.hibernate.type.array.ListArrayType.class",
    ],
  ]

  from(dst)
  into(src)
  exclude("**/Databasechangelog*.java")
  eachFile { state.clear() }
  filter {
    it = generatedValue(it, types, state)
    it = typeDefs(it, types, state)
    it = columnDefinition(it, types, state)
    it = fieldDefinition(it, types, state)
    it = getterOrSetter(it, types, state)
  }
}

task openjpa(type: JavaExec) {
  dependsOn(clean, ":schema:update")

  args = [
    "-annotations", "true",
    "-directory", dst,
    "-metadata", "none",
    "-nullableAsObject", "true",
    "-pkg", "com.github.azell.jooq_utils.sample.entities",
    "-properties", "persistence.xml",
    "-useGenericCollections", "true",
  ]

  classpath = configurations["openjpa"]
  main = "org.apache.openjpa.jdbc.meta.ReverseMappingTool"

  systemProperties = [
    "javax.persistence.jdbc.driver": "org.postgresql.Driver",
    "javax.persistence.jdbc.url": "jdbc:postgresql://localhost:5432/sampledb",
    "javax.persistence.jdbc.user": "postgres",
    "javax.persistence.jdbc.password": "mysecretpassword",
  ]
}
